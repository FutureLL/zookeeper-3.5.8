package com.future.curator;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.recipes.cache.NodeCache;import org.apache.curator.framework.recipes.cache.NodeCacheListener;import org.apache.curator.retry.RetryNTimes;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;/** * @Description: * @Author: lilei58 * @Date: Created in 2021/11/23 上午8:59 */public class CuratorClient {    public static void main(String[] args) throws Exception {        CuratorFramework client = CuratorFrameworkFactory.newClient("localhost:2181", new RetryNTimes(3, 1000));        client.start();        // 创建持久节点        //client.create().withMode(CreateMode.PERSISTENT).forPath("/three", "1".getBytes());        // zk原生监听器,一次性监听        client.getData().usingWatcher(new Watcher() {            @Override            public void process(WatchedEvent event) {                System.out.println("原生 Watcher");            }        }).forPath("/firstNode");        // 对节点进行缓存        NodeCache nodeCache = new NodeCache(client, "/firstNode");        /**         * 参数为true表示: 请求节点内容将内容存放到缓存中,         * 当添加监听器的时候发现真实的 path 所对应的值与缓存中的值一样,并没有改变,因此下边监听器就不会被触发         * 参数为false表示: 并没有将 path 所对应的值存放到缓存中         */        nodeCache.start(true);        // 添加一个监听器,非一次性监听        nodeCache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                System.out.println("被监听");            }        });        System.in.read();    }}